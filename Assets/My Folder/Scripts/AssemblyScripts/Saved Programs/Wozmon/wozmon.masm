; ======================================
; CUSTOM WOZMON FOR MANN 16-BIT
; ======================================

; Variables initialization
.XAMCH
.XAMCH_BK
.STCH
.CH
.YSAV
.ASAV
.MODE               ; $00=XAM, $4A=STOR, $48=BLOCK XAM 

; other variables
.IN = $5000         ; Input buffer to $527F

; my variable
.A_temp             ; temp for A resister

; main program
RESET:
    JSR bit_clear_screen
    LDY #$FFFF
NOTCR:
    CMP #$FF
    BEQ BACKSPACE
    CMP #$FD
    BEQ ESCAPE
    INY
    BCC NEXTCHAR    ; Auto ESC if OFB
ESCAPE:
    LDA #(WELCOME_STR)       ; print square
    JSR ECHOSTR
GETLINE:
    LDA #$FE
    JSR ECHO
    LDY #1
BACKSPACE:
    DEY
    BCS GETLINE
NEXTCHAR:
    DUP
    LDA KBDCR
    BEQ NEXTCHAR    ; wait for key press
    DEC KBDCR       ; reseting KBDCR to 0
    LDA KBD
    STA [IN, Y]     ; Add input to text buffer
    JSR ECHO        ; display character
    CMP #$FE        ; CR?
    BNE NOTCR       ; No.

    LDY #$FFFF
    LDA #$00
    TAX
SETMODE:
    STA MODE        ; $00=XAM, $4A=STOR, $48=BLOCK XAM 
BLSKIP:
    INY             ; INC text index
NEXTITEM:
    DUP
    LDA [IN, Y]     ; Get character
    CMP #$FE        ; CR?
    BEQ GETLINE     ; Yes, done this line.
    CMP #$4E        ; [space]?
    BEQ BLSKIP      ; Skip delimiter
    CMP #$48        ; "."?
    BEQ SETMODE     ; Set BLOCK XAM mode
    CMP #$4A        ; ":"?
    BEQ SETMODE     ; store mode
    CMP #$3B        ; "R"?
    BEQ RUN         ; Run user program
    STX CH          ; $00->CH
    STY YSAV        ; Save Y for comparison
NEXTHEX:
    LDA [IN, Y]      ; Get character for hex test.
    CMP #$14         ; Hex?
    BCS HEX         ; Yes, 2A - 2F
    SUB #$A         ; char - $A = num [0-9]
    JMP DIG         ; jump to DIG
HEX:
    SUB #$20        ; char - $20 = num [A-F]
DIG:
    CMP #$10        ; num >= $10
    BCS NOTHEX      ; Yes, its not a hex.
    ; this part will move CH left a nibble and store num in CH.
    TAX             ; Transfer A -> X
    LDA CH          ; load CH in A
    SLA #4          ; shift A 4 times
    STA CH          ; store shifted CH
    TXA             ; get num back
    LDX #0
    ADD CH          ; CH + num
    STA CH          ; store updated CH
    INY
    JMP NEXTHEX
NOTHEX:
    CPY YSAV        ; Check if CH is empty (no hex digit)
    BEQ ESCAPE      ; Yes, Crash it mf
    LDA MODE
    CMP #$4A        ; MODE != 4A (STOR)
    BNE NOTSTOR
    LDA CH          ; Load character
    STA [STCH], 0   ; Store character in 'store index'
    INC STCH
TONEXTITEM:
    JMP NEXTITEM
;;;;;;;;;;;;;;;;;;;;;;;;;;

RUN:
    JSR [XAMCH], 0     ; Jump to examin index
    JMP RESET
;;;;;;;;;;;;;;;;;;;;;;;;;;

NOTSTOR:
    CMP #$00        ; MODE != 00 (XAM)
    BNE XAMNEXT

    LDA CH
    STA STCH
    STA XAMCH       ; CH = STCH = XAMCH
    STA XAMCH_BK

    LDX #0
NXTPRNT:
    DUP
    BNE PRDATA      ; NE means no address to print

    ; print bin data to right
    INC bit_index
    JSR PRBIN

    LDA #$FE        ; CR.
    JSR ECHO        ; Output it
    LDA XAMCH       ; 'Examine index'
    JSR PRSHORT
    LDA #$4A        ; ":".
    JSR ECHO
PRDATA:
    LDA #00         ; blank
    JSR ECHO
    LDA [XAMCH], 0  ; Get data short at 'examine index'
    JSR PRSHORT

XAMNEXT:
    STX MODE        ; 0->MODE (XAM mode).
    LDA XAMCH
    CMP CH          ; Compare 'examine index' to hex data
    BCS TONEXTITEM  ; Not less, so no more data to output
    INC XAMCH
    LDA XAMCH
    AND #3
    JMP NXTPRNT
;;;;;;;;;;;;;;;;;;;;;;;;;;;

PRBIN:
    LDA XAMCH_BK
    CMP XAMCH           ; if XAMCH_BK == XAMCH
    BEQ PR_BIN_END

    ; INC index       ; space
    LDA [XAMCH_BK], 0
    SRA #8              ; right byte
    BEQ PR_BIN_DOT_RIGHT
    CMP #74
    BCS PR_BIN_DOT_RIGHT
PR_BIN_DOT_RIGHT_END:
    JSR ECHO

    LDA [XAMCH_BK], 0
    AND #$FF             ; left byte
    BEQ PR_BIN_DOT_LEFT
    CMP #74
    BCS PR_BIN_DOT_LEFT
PR_BIN_DOT_LEFT_END:
    JSR ECHO

    INC XAMCH_BK
    JMP PRBIN

PR_BIN_END:
    RTS

PR_BIN_DOT_RIGHT:
    LDA #73             ; "."
    JMP PR_BIN_DOT_RIGHT_END
PR_BIN_DOT_LEFT:
    LDA #73
    JMP PR_BIN_DOT_LEFT_END
;;;;;;;;;;;;;;;;;;;;;;;;;;;

PRSHORT:
    STA ASAV
    SRA #12
    JSR PRHEX
    LDA ASAV
    SRA #8
    JSR PRHEX
    LDA ASAV
    JMP PRBYTE_NOSAVE
PRBYTE:
    STA ASAV
PRBYTE_NOSAVE:
    SRA #4
    JSR PRHEX
    LDA ASAV
PRHEX:
    AND #$000F      ; Mask first 4 bits
    ADD #$A         ; Add "0"
    CMP #20         ; A < 20? Digit?
    BCC ECHO        ; Yes
    ADD #22         ; Add offset for letters
ECHO:
; This code display the character
    STA A_temp
    @print_char A_temp
    LDA A_temp
    RTS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ECHOSTR:
    STA A_temp
    @print_str A_temp
    RTS

WELCOME_STR:
    : "===== WELCOME TO WOZMON ========%%=== PROGRAMS INSTALLED ===%1. BYTEHELL DOOM: 3000%2. PONGO: 3900%3. SNAKYY: 4C00%\"

intrupt:
    LDA #1
    STA KBDCR
    LDA $6F00
    STA KBD
    RTS

` $5900
    JMP ECHO