; ======================================
;   CUSTOM BIOS FOR MANN 16-BIT
; ======================================

.line
.col
.index
.indexStart = $7000
.actual_index
.sc_width = 36
.sc_height = 18
.pix_length = 648
.val
.str_char
.str_msg

; keyboard
.KBD                ; Keyboard input
.KBDCR              ; keyboard control register

; multiply
.mul_temp
.mul_counter
.mul_result

start:
    JMP $5280

~print_str 1 {  ; Print string on screen
    LDA ^1
    STA str_msg
print_str_loop:
    LDA [str_msg], X
    BEQ print_str_done
    STA str_char
    @print_char str_char
    INX
    JMP print_str_loop
print_str_done:
    LDX #0
}

~print_char 1 {  ; Print char on the current position and increment cursor
    @set_char ^1
    INC index
}

~set_char 1 {  ; Set char on the current position of cursor
    LDA index
    ADD #(indexStart)
    STA actual_index
    CMP #$7288
    BCS cls_bios
sc_cls_end:
    LDA ^1
    CMP #$FE                    ; CR?
    BEQ return_bios
    CMP #$FF                    ; backspace?
    BEQ backspace_bios
    CMP #$FD                    ; ESC?
    BEQ set_char_end
    STA [actual_index], 0
set_char_end:
    DUP
}

clear_screen:
    CLS
    LDA #00
    STA index
    LDA #(indexStart)
    STA actual_index
    DUP
    RTS

cls_bios:
    JSR clear_screen
    JMP sc_cls_end

new_line:
.mod_val
    PHA
    @mod index #(sc_width)
    STA mod_val
    LDA #(sc_width)
    SUB mod_val
    ADD index
    STA index
    CMP #(pix_length)
    BNE check_pix_end
    LDA #0
    STA index
    CNP
check_pix_end:
    PLA
    RTS

return_bios:
    JSR new_line
    DEC index
    JMP set_char_end

backspace_bios:
    DEC index
    @set_char #0
    DEC index
    JMP set_char_end


~multiply 0 {   ; multiply two numbers (A * X)
    STA mul_temp
    STX mul_counter

    LDA #0
    STA mul_result

mul_loop:
    LDA mul_counter
    BEQ mul_end        ; if counter = 0 --> done

    LDA mul_result
    ADD mul_temp
    STA mul_result      ; result += multiplicand

    DEC mul_counter     ; counter--
    JMP mul_loop
mul_end:
    LDA mul_result      ; return with A = result
}

~mod 2 {
; A, B
    LDA ^1
mod_loop:
    CMP ^2
    BCC break_mod
    SUB ^2
    JMP mod_loop
break_mod:
}

~wait 1 {
    LDX ^1
wait_loop:
    DEX
    BEQ wait_end
    NOP
    NOP
    NOP
    NOP
    JMP wait_loop
wait_end:
}

#link "main"

` $6DF0
    JMP intrupt